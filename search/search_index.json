{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"mpf-utils Documentation","text":"<p>mpf-utils are the utility classes that the MeyerPerin Foundation uses to interact with Azure services and OpenAI APIs.</p>"},{"location":"#overview","title":"Overview","text":"<p>This project includes:</p> <ul> <li>Azure Storage Utilities: Manage interactions with Azure Blob Storage.</li> <li>CosmosDB Utilities: Perform common operations with Azure CosmosDB.</li> <li>AI Integration: Use a unified client to interact with both Azure OpenAI and the standard OpenAI API.</li> </ul> <p>For detailed API information, please refer to the API Reference.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<ol> <li> <p>Installation:    Install the package and its dependencies via pip.</p> </li> <li> <p>Usage:    Import the desired class and refer to the API reference for details on methods and parameters.</p> </li> </ol>"},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#ai-integration","title":"AI Integration","text":""},{"location":"reference/#openaiclient","title":"OpenAIClient","text":"<p>A client for interacting with OpenAI's API, supporting both Azure OpenAI and the standard OpenAI service.</p> <p>Depending on the 'azure' flag, the client is configured to use either Azure's OpenAI endpoint and API key or the standard OpenAI API key. When using Azure, the client extracts the deployment name and API version from the provided endpoint.</p> Source code in <code>src\\mpfutils\\ai\\oai.py</code> <pre><code>class OpenAIClient:\n    \"\"\"\n    A client for interacting with OpenAI's API, supporting both Azure OpenAI and the standard OpenAI service.\n\n    Depending on the 'azure' flag, the client is configured to use either Azure's OpenAI endpoint\n    and API key or the standard OpenAI API key. When using Azure, the client extracts the deployment\n    name and API version from the provided endpoint.\n    \"\"\"\n\n    def __init__(\n        self,\n        azure: bool = True,\n        api_key: str = None,\n        azure_endpoint: str = None,\n        model: str = None,\n        azure_openai_api_version: str = \"2024-10-21\"\n    ):\n        \"\"\"\n        Initialize the OpenAIClient.\n\n        Parameters:\n            azure (bool): Flag indicating whether to use Azure OpenAI (True) or the standard OpenAI service (False).\n            api_key (str, optional): The API key for authentication. For Azure, if not provided, it is fetched from\n                the environment variable 'MPFU_AZURE_OPENAI_API_KEY'. For standard OpenAI, it is fetched from\n                'MPFU_OPENAI_API_KEY' if not provided.\n            azure_endpoint (str, optional): The Azure OpenAI endpoint URL. If not provided, it is fetched from the\n                environment variable 'MPFU_AZURE_OPENAI_ENDPOINT'.\n            model (str, optional): The model identifier to use when not using Azure. For Azure, the model is derived\n                from the deployment information in the endpoint.\n            azure_openai_api_version (str, optional): The API version for Azure OpenAI. Defaults to \"2024-10-21\".\n\n        Notes:\n            - When using Azure, the endpoint URL is parsed to extract the deployment name and API version.\n            - The Azure configuration takes precedence if the 'azure' flag is set to True.\n        \"\"\"\n        self.azure = azure\n\n        if self.azure:\n            if not azure_endpoint:\n                azure_endpoint = os.getenv(\"MPFU_AZURE_OPENAI_ENDPOINT\")\n\n            if not api_key:\n                api_key = os.getenv(\"MPFU_AZURE_OPENAI_API_KEY\")\n\n            # Extract the deployment name from the endpoint (assumes a specific URL structure)\n            self.deployment = azure_endpoint.split(\"/\")[-3]\n            self.model = self.deployment\n\n            # Extract the API version from the endpoint by splitting on '='\n            self.api_version = azure_endpoint.split(\"=\")[-1]\n\n            self.client = AzureOpenAI(\n                azure_endpoint=azure_endpoint,\n                api_key=api_key,\n                api_version=self.api_version,\n            )\n\n            logger.info(\n                f\"Using Azure OpenAI with:\\nendpoint {azure_endpoint}\\nendpoint model {self.model}\\nendpoint api version {self.api_version}\"\n            )\n        else:\n            # Using the standard OpenAI service\n            if not api_key:\n                api_key = os.getenv(\"MPFU_OPENAI_API_KEY\")\n\n            self.model = model\n            self.client = OpenAI(api_key=api_key)\n            logger.info(\"Using OpenAI\")\n\n    def run_prompt(self, prompt: str, model: str = None) -&gt; str:\n        \"\"\"\n        Run a prompt through the OpenAI service and retrieve the generated response.\n\n        Parameters:\n            prompt (str): The prompt text to send to the OpenAI service.\n            model (str, optional): The model identifier to use. If not provided, the client's default model is used.\n\n        Returns:\n            str: The content of the response generated by the AI. Returns None if an error occurs.\n\n        Notes:\n            - The method uses the chat completion endpoint, sending the prompt as a user message.\n            - In case of an exception, the error is logged and None is returned.\n        \"\"\"\n        model = model or self.model\n        try:\n            response = self.client.chat.completions.create(\n                messages=[{\"role\": \"user\", \"content\": prompt}],\n                model=model,\n            )\n            return response.choices[0].message.content\n\n        except Exception as e:\n            logger.error(f\"Error in AI client: {e}\")\n            return None\n</code></pre>"},{"location":"reference/#ai.oai.OpenAIClient.__init__","title":"<code>__init__(azure=True, api_key=None, azure_endpoint=None, model=None, azure_openai_api_version='2024-10-21')</code>","text":"<p>Initialize the OpenAIClient.</p> <p>Parameters:</p> Name Type Description Default <code>azure</code> <code>bool</code> <p>Flag indicating whether to use Azure OpenAI (True) or the standard OpenAI service (False).</p> <code>True</code> <code>api_key</code> <code>str</code> <p>The API key for authentication. For Azure, if not provided, it is fetched from the environment variable 'MPFU_AZURE_OPENAI_API_KEY'. For standard OpenAI, it is fetched from 'MPFU_OPENAI_API_KEY' if not provided.</p> <code>None</code> <code>azure_endpoint</code> <code>str</code> <p>The Azure OpenAI endpoint URL. If not provided, it is fetched from the environment variable 'MPFU_AZURE_OPENAI_ENDPOINT'.</p> <code>None</code> <code>model</code> <code>str</code> <p>The model identifier to use when not using Azure. For Azure, the model is derived from the deployment information in the endpoint.</p> <code>None</code> <code>azure_openai_api_version</code> <code>str</code> <p>The API version for Azure OpenAI. Defaults to \"2024-10-21\".</p> <code>'2024-10-21'</code> Notes <ul> <li>When using Azure, the endpoint URL is parsed to extract the deployment name and API version.</li> <li>The Azure configuration takes precedence if the 'azure' flag is set to True.</li> </ul> Source code in <code>src\\mpfutils\\ai\\oai.py</code> <pre><code>def __init__(\n    self,\n    azure: bool = True,\n    api_key: str = None,\n    azure_endpoint: str = None,\n    model: str = None,\n    azure_openai_api_version: str = \"2024-10-21\"\n):\n    \"\"\"\n    Initialize the OpenAIClient.\n\n    Parameters:\n        azure (bool): Flag indicating whether to use Azure OpenAI (True) or the standard OpenAI service (False).\n        api_key (str, optional): The API key for authentication. For Azure, if not provided, it is fetched from\n            the environment variable 'MPFU_AZURE_OPENAI_API_KEY'. For standard OpenAI, it is fetched from\n            'MPFU_OPENAI_API_KEY' if not provided.\n        azure_endpoint (str, optional): The Azure OpenAI endpoint URL. If not provided, it is fetched from the\n            environment variable 'MPFU_AZURE_OPENAI_ENDPOINT'.\n        model (str, optional): The model identifier to use when not using Azure. For Azure, the model is derived\n            from the deployment information in the endpoint.\n        azure_openai_api_version (str, optional): The API version for Azure OpenAI. Defaults to \"2024-10-21\".\n\n    Notes:\n        - When using Azure, the endpoint URL is parsed to extract the deployment name and API version.\n        - The Azure configuration takes precedence if the 'azure' flag is set to True.\n    \"\"\"\n    self.azure = azure\n\n    if self.azure:\n        if not azure_endpoint:\n            azure_endpoint = os.getenv(\"MPFU_AZURE_OPENAI_ENDPOINT\")\n\n        if not api_key:\n            api_key = os.getenv(\"MPFU_AZURE_OPENAI_API_KEY\")\n\n        # Extract the deployment name from the endpoint (assumes a specific URL structure)\n        self.deployment = azure_endpoint.split(\"/\")[-3]\n        self.model = self.deployment\n\n        # Extract the API version from the endpoint by splitting on '='\n        self.api_version = azure_endpoint.split(\"=\")[-1]\n\n        self.client = AzureOpenAI(\n            azure_endpoint=azure_endpoint,\n            api_key=api_key,\n            api_version=self.api_version,\n        )\n\n        logger.info(\n            f\"Using Azure OpenAI with:\\nendpoint {azure_endpoint}\\nendpoint model {self.model}\\nendpoint api version {self.api_version}\"\n        )\n    else:\n        # Using the standard OpenAI service\n        if not api_key:\n            api_key = os.getenv(\"MPFU_OPENAI_API_KEY\")\n\n        self.model = model\n        self.client = OpenAI(api_key=api_key)\n        logger.info(\"Using OpenAI\")\n</code></pre>"},{"location":"reference/#ai.oai.OpenAIClient.run_prompt","title":"<code>run_prompt(prompt, model=None)</code>","text":"<p>Run a prompt through the OpenAI service and retrieve the generated response.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The prompt text to send to the OpenAI service.</p> required <code>model</code> <code>str</code> <p>The model identifier to use. If not provided, the client's default model is used.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The content of the response generated by the AI. Returns None if an error occurs.</p> Notes <ul> <li>The method uses the chat completion endpoint, sending the prompt as a user message.</li> <li>In case of an exception, the error is logged and None is returned.</li> </ul> Source code in <code>src\\mpfutils\\ai\\oai.py</code> <pre><code>def run_prompt(self, prompt: str, model: str = None) -&gt; str:\n    \"\"\"\n    Run a prompt through the OpenAI service and retrieve the generated response.\n\n    Parameters:\n        prompt (str): The prompt text to send to the OpenAI service.\n        model (str, optional): The model identifier to use. If not provided, the client's default model is used.\n\n    Returns:\n        str: The content of the response generated by the AI. Returns None if an error occurs.\n\n    Notes:\n        - The method uses the chat completion endpoint, sending the prompt as a user message.\n        - In case of an exception, the error is logged and None is returned.\n    \"\"\"\n    model = model or self.model\n    try:\n        response = self.client.chat.completions.create(\n            messages=[{\"role\": \"user\", \"content\": prompt}],\n            model=model,\n        )\n        return response.choices[0].message.content\n\n    except Exception as e:\n        logger.error(f\"Error in AI client: {e}\")\n        return None\n</code></pre>"},{"location":"reference/#database","title":"Database","text":""},{"location":"reference/#cosmosdbclient","title":"CosmosDBClient","text":"<p>A client for interacting with a specific CosmosDB container.</p> <p>This class provides methods to run queries, delete, upsert, retrieve a single item, or retrieve all items from a container in a CosmosDB database.</p> Source code in <code>src\\mpfutils\\cosmosdb\\cdb_client.py</code> <pre><code>class CosmosDBContainer:\n    \"\"\"\n    A client for interacting with a specific CosmosDB container.\n\n    This class provides methods to run queries, delete, upsert, retrieve a single item,\n    or retrieve all items from a container in a CosmosDB database.\n    \"\"\"\n\n    def __init__(self, database_name: str, container_name: str, endpoint: str = None, key: str = None, conn_str: str = None):\n        \"\"\"\n        Initialize the CosmosDBContainer.\n\n        Parameters:\n            database_name (str): The name of the CosmosDB database.\n            container_name (str): The name of the container within the database.\n            endpoint (str, optional): The CosmosDB endpoint URL. If not provided, the environment variable 'MPFU_COSMOSDB_ENDPOINT' is used.\n            key (str, optional): The primary key for the CosmosDB account. If not provided, the environment variable 'MPFU_COSMOSDB_KEY' is used.\n            conn_str (str, optional): A connection string for CosmosDB. If provided, it takes precedence over the endpoint and key.\n\n        Notes:\n            - If neither endpoint nor key are provided, the constructor attempts to load them from the environment.\n            - The connection string, if provided, will override the endpoint and key.\n        \"\"\"\n        if not endpoint:\n            endpoint = os.getenv(\"MPFU_COSMOSDB_ENDPOINT\")\n\n        if not key:\n            key = os.getenv(\"MPFU_COSMOSDB_KEY\")\n\n        if conn_str:\n            logger.info(\"Using connection string to connect to CosmosDB\")\n            client = CosmosClient.from_connection_string(conn_str)\n        else:\n            logger.info(\"Using endpoint and key to connect to CosmosDB\")\n            client = CosmosClient(endpoint, key)\n\n        database = client.get_database_client(database_name)\n        self.container = database.get_container_client(container_name)\n\n    def run_query(self, query: str, parameters: list = None, results_as_list: bool = True):\n        \"\"\"\n        Run a query against the CosmosDB container.\n\n        Parameters:\n            query (str): The SQL query string to execute.\n            parameters (list, optional): A list of parameters to be used with the query.\n                Defaults to an empty list if not provided.\n            results_as_list (bool, optional): Determines whether the results should be returned as a list.\n                If False, an iterable is returned. Defaults to True.\n\n        Returns:\n            list or iterator: The query results as a list if results_as_list is True; otherwise, an iterator.\n            Returns None if an error occurs during the query.\n\n        Notes:\n            - The query is executed with cross-partition querying enabled.\n        \"\"\"\n        if not parameters:\n            parameters = []\n\n        try:\n            items = self.container.query_items(\n                query=query,\n                parameters=parameters,\n                enable_cross_partition_query=True,\n            )\n            if results_as_list:\n                return list(items)\n            else:\n                return items\n        except Exception as e:\n            logger.error(f\"Error in CosmosDBContainer: {e}\")\n            raise e\n\n    def delete_item(self, item_id: str, partition_key: str = None):\n        \"\"\"\n        Delete an item from the CosmosDB container.\n\n        Parameters:\n            item_id (str): The unique identifier of the item to delete.\n            partition_key (str, optional): The partition key for the item.\n                If not provided, the item_id is used as the partition key.\n\n        Returns:\n            bool: True if the deletion was successful, False otherwise.\n        \"\"\"\n        if not partition_key:\n            partition_key = item_id\n        try:\n            self.container.delete_item(item=item_id, partition_key=partition_key)\n            return True\n        except Exception as e:\n            logger.error(f\"Error in CosmosDBContainer: {e}\")\n            raise e\n\n\n    def upsert_item(self, item: dict):\n        \"\"\"\n        Upsert (update or insert) an item in the CosmosDB container.\n\n        Parameters:\n            item (dict): A dictionary representing the item to upsert.\n\n        Returns:\n            bool: True if the upsert operation was successful, False otherwise.\n        \"\"\"\n        try:\n            self.container.upsert_item(item)\n            return True\n        except Exception as e:\n            logger.error(f\"Error in CosmosDBContainer: {e}\")\n            raise e\n\n    def get_item(self, item_id: str, partition_key: str = None):\n        \"\"\"\n        Retrieve a single item from the CosmosDB container.\n\n        Parameters:\n            item_id (str): The unique identifier of the item to retrieve.\n            partition_key (str, optional): The partition key for the item.\n                If not provided, the item_id is used as the partition key.\n\n        Returns:\n            dict: The retrieved item as a dictionary if found.\n            Returns None if an error occurs or the item is not found.\n        \"\"\"\n        if not partition_key:\n            partition_key = item_id\n        try:\n            item = self.container.read_item(item=item_id, partition_key=partition_key)\n            return item\n        except Exception as e:\n            logger.error(f\"Error in CosmosDBContainer: {e}\")\n            raise e\n\n    def get_all_items(self, max_item_count: int = None, results_as_list: bool = True):\n        \"\"\"\n        Retrieve all items from the CosmosDB container.\n\n        Parameters:\n            max_item_count (int, optional): The maximum number of items to retrieve.\n                Currently, this parameter is not used by the underlying API call.\n            results_as_list (bool, optional): Determines whether the results should be returned as a list.\n                If False, an iterable is returned. Defaults to True.\n\n        Returns:\n            list or iterator: The items in the container as a list if results_as_list is True; otherwise, an iterator.\n            Returns None if an error occurs during retrieval.\n        \"\"\"\n        try:\n            items = self.container.read_all_items()\n            if results_as_list:\n                return list(items)\n            else:\n                return items\n        except Exception as e:\n            logger.error(f\"Error in CosmosDBContainer: {e}\")\n            raise e\n</code></pre>"},{"location":"reference/#cosmosdb.cdb_client.CosmosDBContainer.__init__","title":"<code>__init__(database_name, container_name, endpoint=None, key=None, conn_str=None)</code>","text":"<p>Initialize the CosmosDBContainer.</p> <p>Parameters:</p> Name Type Description Default <code>database_name</code> <code>str</code> <p>The name of the CosmosDB database.</p> required <code>container_name</code> <code>str</code> <p>The name of the container within the database.</p> required <code>endpoint</code> <code>str</code> <p>The CosmosDB endpoint URL. If not provided, the environment variable 'MPFU_COSMOSDB_ENDPOINT' is used.</p> <code>None</code> <code>key</code> <code>str</code> <p>The primary key for the CosmosDB account. If not provided, the environment variable 'MPFU_COSMOSDB_KEY' is used.</p> <code>None</code> <code>conn_str</code> <code>str</code> <p>A connection string for CosmosDB. If provided, it takes precedence over the endpoint and key.</p> <code>None</code> Notes <ul> <li>If neither endpoint nor key are provided, the constructor attempts to load them from the environment.</li> <li>The connection string, if provided, will override the endpoint and key.</li> </ul> Source code in <code>src\\mpfutils\\cosmosdb\\cdb_client.py</code> <pre><code>def __init__(self, database_name: str, container_name: str, endpoint: str = None, key: str = None, conn_str: str = None):\n    \"\"\"\n    Initialize the CosmosDBContainer.\n\n    Parameters:\n        database_name (str): The name of the CosmosDB database.\n        container_name (str): The name of the container within the database.\n        endpoint (str, optional): The CosmosDB endpoint URL. If not provided, the environment variable 'MPFU_COSMOSDB_ENDPOINT' is used.\n        key (str, optional): The primary key for the CosmosDB account. If not provided, the environment variable 'MPFU_COSMOSDB_KEY' is used.\n        conn_str (str, optional): A connection string for CosmosDB. If provided, it takes precedence over the endpoint and key.\n\n    Notes:\n        - If neither endpoint nor key are provided, the constructor attempts to load them from the environment.\n        - The connection string, if provided, will override the endpoint and key.\n    \"\"\"\n    if not endpoint:\n        endpoint = os.getenv(\"MPFU_COSMOSDB_ENDPOINT\")\n\n    if not key:\n        key = os.getenv(\"MPFU_COSMOSDB_KEY\")\n\n    if conn_str:\n        logger.info(\"Using connection string to connect to CosmosDB\")\n        client = CosmosClient.from_connection_string(conn_str)\n    else:\n        logger.info(\"Using endpoint and key to connect to CosmosDB\")\n        client = CosmosClient(endpoint, key)\n\n    database = client.get_database_client(database_name)\n    self.container = database.get_container_client(container_name)\n</code></pre>"},{"location":"reference/#cosmosdb.cdb_client.CosmosDBContainer.delete_item","title":"<code>delete_item(item_id, partition_key=None)</code>","text":"<p>Delete an item from the CosmosDB container.</p> <p>Parameters:</p> Name Type Description Default <code>item_id</code> <code>str</code> <p>The unique identifier of the item to delete.</p> required <code>partition_key</code> <code>str</code> <p>The partition key for the item. If not provided, the item_id is used as the partition key.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the deletion was successful, False otherwise.</p> Source code in <code>src\\mpfutils\\cosmosdb\\cdb_client.py</code> <pre><code>def delete_item(self, item_id: str, partition_key: str = None):\n    \"\"\"\n    Delete an item from the CosmosDB container.\n\n    Parameters:\n        item_id (str): The unique identifier of the item to delete.\n        partition_key (str, optional): The partition key for the item.\n            If not provided, the item_id is used as the partition key.\n\n    Returns:\n        bool: True if the deletion was successful, False otherwise.\n    \"\"\"\n    if not partition_key:\n        partition_key = item_id\n    try:\n        self.container.delete_item(item=item_id, partition_key=partition_key)\n        return True\n    except Exception as e:\n        logger.error(f\"Error in CosmosDBContainer: {e}\")\n        raise e\n</code></pre>"},{"location":"reference/#cosmosdb.cdb_client.CosmosDBContainer.get_all_items","title":"<code>get_all_items(max_item_count=None, results_as_list=True)</code>","text":"<p>Retrieve all items from the CosmosDB container.</p> <p>Parameters:</p> Name Type Description Default <code>max_item_count</code> <code>int</code> <p>The maximum number of items to retrieve. Currently, this parameter is not used by the underlying API call.</p> <code>None</code> <code>results_as_list</code> <code>bool</code> <p>Determines whether the results should be returned as a list. If False, an iterable is returned. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <p>list or iterator: The items in the container as a list if results_as_list is True; otherwise, an iterator.</p> <p>Returns None if an error occurs during retrieval.</p> Source code in <code>src\\mpfutils\\cosmosdb\\cdb_client.py</code> <pre><code>def get_all_items(self, max_item_count: int = None, results_as_list: bool = True):\n    \"\"\"\n    Retrieve all items from the CosmosDB container.\n\n    Parameters:\n        max_item_count (int, optional): The maximum number of items to retrieve.\n            Currently, this parameter is not used by the underlying API call.\n        results_as_list (bool, optional): Determines whether the results should be returned as a list.\n            If False, an iterable is returned. Defaults to True.\n\n    Returns:\n        list or iterator: The items in the container as a list if results_as_list is True; otherwise, an iterator.\n        Returns None if an error occurs during retrieval.\n    \"\"\"\n    try:\n        items = self.container.read_all_items()\n        if results_as_list:\n            return list(items)\n        else:\n            return items\n    except Exception as e:\n        logger.error(f\"Error in CosmosDBContainer: {e}\")\n        raise e\n</code></pre>"},{"location":"reference/#cosmosdb.cdb_client.CosmosDBContainer.get_item","title":"<code>get_item(item_id, partition_key=None)</code>","text":"<p>Retrieve a single item from the CosmosDB container.</p> <p>Parameters:</p> Name Type Description Default <code>item_id</code> <code>str</code> <p>The unique identifier of the item to retrieve.</p> required <code>partition_key</code> <code>str</code> <p>The partition key for the item. If not provided, the item_id is used as the partition key.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The retrieved item as a dictionary if found.</p> <p>Returns None if an error occurs or the item is not found.</p> Source code in <code>src\\mpfutils\\cosmosdb\\cdb_client.py</code> <pre><code>def get_item(self, item_id: str, partition_key: str = None):\n    \"\"\"\n    Retrieve a single item from the CosmosDB container.\n\n    Parameters:\n        item_id (str): The unique identifier of the item to retrieve.\n        partition_key (str, optional): The partition key for the item.\n            If not provided, the item_id is used as the partition key.\n\n    Returns:\n        dict: The retrieved item as a dictionary if found.\n        Returns None if an error occurs or the item is not found.\n    \"\"\"\n    if not partition_key:\n        partition_key = item_id\n    try:\n        item = self.container.read_item(item=item_id, partition_key=partition_key)\n        return item\n    except Exception as e:\n        logger.error(f\"Error in CosmosDBContainer: {e}\")\n        raise e\n</code></pre>"},{"location":"reference/#cosmosdb.cdb_client.CosmosDBContainer.run_query","title":"<code>run_query(query, parameters=None, results_as_list=True)</code>","text":"<p>Run a query against the CosmosDB container.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The SQL query string to execute.</p> required <code>parameters</code> <code>list</code> <p>A list of parameters to be used with the query. Defaults to an empty list if not provided.</p> <code>None</code> <code>results_as_list</code> <code>bool</code> <p>Determines whether the results should be returned as a list. If False, an iterable is returned. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <p>list or iterator: The query results as a list if results_as_list is True; otherwise, an iterator.</p> <p>Returns None if an error occurs during the query.</p> Notes <ul> <li>The query is executed with cross-partition querying enabled.</li> </ul> Source code in <code>src\\mpfutils\\cosmosdb\\cdb_client.py</code> <pre><code>def run_query(self, query: str, parameters: list = None, results_as_list: bool = True):\n    \"\"\"\n    Run a query against the CosmosDB container.\n\n    Parameters:\n        query (str): The SQL query string to execute.\n        parameters (list, optional): A list of parameters to be used with the query.\n            Defaults to an empty list if not provided.\n        results_as_list (bool, optional): Determines whether the results should be returned as a list.\n            If False, an iterable is returned. Defaults to True.\n\n    Returns:\n        list or iterator: The query results as a list if results_as_list is True; otherwise, an iterator.\n        Returns None if an error occurs during the query.\n\n    Notes:\n        - The query is executed with cross-partition querying enabled.\n    \"\"\"\n    if not parameters:\n        parameters = []\n\n    try:\n        items = self.container.query_items(\n            query=query,\n            parameters=parameters,\n            enable_cross_partition_query=True,\n        )\n        if results_as_list:\n            return list(items)\n        else:\n            return items\n    except Exception as e:\n        logger.error(f\"Error in CosmosDBContainer: {e}\")\n        raise e\n</code></pre>"},{"location":"reference/#cosmosdb.cdb_client.CosmosDBContainer.upsert_item","title":"<code>upsert_item(item)</code>","text":"<p>Upsert (update or insert) an item in the CosmosDB container.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>dict</code> <p>A dictionary representing the item to upsert.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the upsert operation was successful, False otherwise.</p> Source code in <code>src\\mpfutils\\cosmosdb\\cdb_client.py</code> <pre><code>def upsert_item(self, item: dict):\n    \"\"\"\n    Upsert (update or insert) an item in the CosmosDB container.\n\n    Parameters:\n        item (dict): A dictionary representing the item to upsert.\n\n    Returns:\n        bool: True if the upsert operation was successful, False otherwise.\n    \"\"\"\n    try:\n        self.container.upsert_item(item)\n        return True\n    except Exception as e:\n        logger.error(f\"Error in CosmosDBContainer: {e}\")\n        raise e\n</code></pre>"},{"location":"reference/#storage","title":"Storage","text":""},{"location":"reference/#blobstorageclient","title":"BlobStorageClient","text":"<p>A client for interacting with an Azure Blob Storage container.</p> <p>This class allows uploading and downloading blobs from an Azure Storage container. It can establish the connection using either a connection string (with a specified container) or a SAS (Shared Access Signature) URL.</p> Source code in <code>src\\mpfutils\\azstorage\\azs_container.py</code> <pre><code>class AzsContainerClient:\n    \"\"\"\n    A client for interacting with an Azure Blob Storage container.\n\n    This class allows uploading and downloading blobs from an Azure Storage container.\n    It can establish the connection using either a connection string (with a specified container)\n    or a SAS (Shared Access Signature) URL.\n    \"\"\"\n\n    def __init__(self, container_name: str = None, conn_str: str = None, sas_url: str = None):\n        \"\"\"\n        Initialize the AzsContainerClient.\n\n        Parameters:\n            container_name (str, optional): The name of the container. This is required when using a connection string.\n            conn_str (str, optional): The connection string for the Azure Storage account.\n                If not provided, the connection string will be fetched from the environment variable 'MPFU_AZSTORAGE_CONNECTION_STRING'.\n            sas_url (str, optional): The SAS URL for the container. If provided, it overrides the connection string.\n\n        Notes:\n            - If neither 'conn_str' nor 'sas_url' is provided, the connection string is obtained from the environment.\n            - The SAS URL, if provided, takes precedence over the connection string.\n        \"\"\"\n        if not conn_str and not sas_url:\n            conn_str = os.getenv(\"MPFU_AZSTORAGE_CONNECTION_STRING\")\n\n        if not sas_url:\n            logger.info(\"Using connection string to connect to Azure Storage\")\n            blob_service_client = BlobServiceClient.from_connection_string(conn_str)\n            self.container_client = blob_service_client.get_container_client(container_name)\n        else:\n            # If a sas_url is provided, it overrides the connection string.\n            logger.info(\"Using SAS URL to connect to Azure Storage\")\n            self.container_client = ContainerClient.from_container_url(sas_url)\n\n    def upload_blob(self, blob_name, data, overwrite=True):\n        \"\"\"\n        Upload data to a blob within the container.\n\n        Parameters:\n            blob_name (str): The name of the blob to be created or overwritten.\n            data (bytes or str): The data to upload to the blob.\n            overwrite (bool, optional): Whether to overwrite an existing blob with the same name. Defaults to True.\n\n        Returns:\n            str: The URL of the uploaded blob.\n\n        Notes:\n            - The upload is performed with a maximum concurrency of 8 and a maximum blob size of 8 MB.\n        \"\"\"\n        blob_client = self.container_client.get_blob_client(blob=blob_name)\n        blob_client.upload_blob(data, overwrite=overwrite, max_concurrency=8, max_blob_size=8*1024*1024)\n        return blob_client.url\n\n    def download_blob(self, container_name, blob_name):\n        \"\"\"\n        Download the content of a blob from the container.\n\n        Parameters:\n            container_name (str): The name of the container. \n                Note: This parameter is currently not used since the container is already specified during initialization.\n            blob_name (str): The name of the blob to download.\n\n        Returns:\n            bytes: The content of the blob.\n\n        Notes:\n            - The 'container_name' parameter is included for potential future use, but it is unused in the current implementation.\n        \"\"\"\n        blob_client = self.container_client.get_blob_client(blob=blob_name)\n        return blob_client.download_blob().readall()\n</code></pre>"},{"location":"reference/#azstorage.azs_container.AzsContainerClient.__init__","title":"<code>__init__(container_name=None, conn_str=None, sas_url=None)</code>","text":"<p>Initialize the AzsContainerClient.</p> <p>Parameters:</p> Name Type Description Default <code>container_name</code> <code>str</code> <p>The name of the container. This is required when using a connection string.</p> <code>None</code> <code>conn_str</code> <code>str</code> <p>The connection string for the Azure Storage account. If not provided, the connection string will be fetched from the environment variable 'MPFU_AZSTORAGE_CONNECTION_STRING'.</p> <code>None</code> <code>sas_url</code> <code>str</code> <p>The SAS URL for the container. If provided, it overrides the connection string.</p> <code>None</code> Notes <ul> <li>If neither 'conn_str' nor 'sas_url' is provided, the connection string is obtained from the environment.</li> <li>The SAS URL, if provided, takes precedence over the connection string.</li> </ul> Source code in <code>src\\mpfutils\\azstorage\\azs_container.py</code> <pre><code>def __init__(self, container_name: str = None, conn_str: str = None, sas_url: str = None):\n    \"\"\"\n    Initialize the AzsContainerClient.\n\n    Parameters:\n        container_name (str, optional): The name of the container. This is required when using a connection string.\n        conn_str (str, optional): The connection string for the Azure Storage account.\n            If not provided, the connection string will be fetched from the environment variable 'MPFU_AZSTORAGE_CONNECTION_STRING'.\n        sas_url (str, optional): The SAS URL for the container. If provided, it overrides the connection string.\n\n    Notes:\n        - If neither 'conn_str' nor 'sas_url' is provided, the connection string is obtained from the environment.\n        - The SAS URL, if provided, takes precedence over the connection string.\n    \"\"\"\n    if not conn_str and not sas_url:\n        conn_str = os.getenv(\"MPFU_AZSTORAGE_CONNECTION_STRING\")\n\n    if not sas_url:\n        logger.info(\"Using connection string to connect to Azure Storage\")\n        blob_service_client = BlobServiceClient.from_connection_string(conn_str)\n        self.container_client = blob_service_client.get_container_client(container_name)\n    else:\n        # If a sas_url is provided, it overrides the connection string.\n        logger.info(\"Using SAS URL to connect to Azure Storage\")\n        self.container_client = ContainerClient.from_container_url(sas_url)\n</code></pre>"},{"location":"reference/#azstorage.azs_container.AzsContainerClient.download_blob","title":"<code>download_blob(container_name, blob_name)</code>","text":"<p>Download the content of a blob from the container.</p> <p>Parameters:</p> Name Type Description Default <code>container_name</code> <code>str</code> <p>The name of the container.  Note: This parameter is currently not used since the container is already specified during initialization.</p> required <code>blob_name</code> <code>str</code> <p>The name of the blob to download.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <p>The content of the blob.</p> Notes <ul> <li>The 'container_name' parameter is included for potential future use, but it is unused in the current implementation.</li> </ul> Source code in <code>src\\mpfutils\\azstorage\\azs_container.py</code> <pre><code>def download_blob(self, container_name, blob_name):\n    \"\"\"\n    Download the content of a blob from the container.\n\n    Parameters:\n        container_name (str): The name of the container. \n            Note: This parameter is currently not used since the container is already specified during initialization.\n        blob_name (str): The name of the blob to download.\n\n    Returns:\n        bytes: The content of the blob.\n\n    Notes:\n        - The 'container_name' parameter is included for potential future use, but it is unused in the current implementation.\n    \"\"\"\n    blob_client = self.container_client.get_blob_client(blob=blob_name)\n    return blob_client.download_blob().readall()\n</code></pre>"},{"location":"reference/#azstorage.azs_container.AzsContainerClient.upload_blob","title":"<code>upload_blob(blob_name, data, overwrite=True)</code>","text":"<p>Upload data to a blob within the container.</p> <p>Parameters:</p> Name Type Description Default <code>blob_name</code> <code>str</code> <p>The name of the blob to be created or overwritten.</p> required <code>data</code> <code>bytes or str</code> <p>The data to upload to the blob.</p> required <code>overwrite</code> <code>bool</code> <p>Whether to overwrite an existing blob with the same name. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>str</code> <p>The URL of the uploaded blob.</p> Notes <ul> <li>The upload is performed with a maximum concurrency of 8 and a maximum blob size of 8 MB.</li> </ul> Source code in <code>src\\mpfutils\\azstorage\\azs_container.py</code> <pre><code>def upload_blob(self, blob_name, data, overwrite=True):\n    \"\"\"\n    Upload data to a blob within the container.\n\n    Parameters:\n        blob_name (str): The name of the blob to be created or overwritten.\n        data (bytes or str): The data to upload to the blob.\n        overwrite (bool, optional): Whether to overwrite an existing blob with the same name. Defaults to True.\n\n    Returns:\n        str: The URL of the uploaded blob.\n\n    Notes:\n        - The upload is performed with a maximum concurrency of 8 and a maximum blob size of 8 MB.\n    \"\"\"\n    blob_client = self.container_client.get_blob_client(blob=blob_name)\n    blob_client.upload_blob(data, overwrite=overwrite, max_concurrency=8, max_blob_size=8*1024*1024)\n    return blob_client.url\n</code></pre>"}]}